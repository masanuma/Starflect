# 12ÊòüÂ∫ßÂà•„Ç¢„Ç´„Ç¶„É≥„ÉàÂÆüË£ÖÊâãÈ†ÜÊõ∏

## üìã Ê¶ÇË¶Å

**„Éó„É≠„Ç∏„Çß„ÇØ„Éà**: 12ÊòüÂ∫ßÂà•„Ç¢„Ç´„Ç¶„É≥„ÉàËá™ÂãïÈÖç‰ø°„Ç∑„Çπ„ÉÜ„É†
**ÁõÆÁöÑ**: AIÁîüÊàê„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆËá™ÂãïÈÖç‰ø°„Å´„Çà„ÇãÂèéÁõäÂåñ
**ÂØæË±°„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†**: Instagram, Twitter, TikTok
**ÂÆüË£ÖÊúüÈñì**: 8„É∂ÊúàÔºàÊÆµÈöéÁöÑÂÆüË£ÖÔºâ

## üèóÔ∏è Phase 1: Ê¶ÇÂøµÂÆüË®ºÔºà1-2„É∂ÊúàÔºâ

### 1.1 ÈñãÁô∫Áí∞Â¢ÉÊßãÁØâ

#### ÂøÖË¶Å„Å™„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢
```bash
# Node.jsÁí∞Â¢É„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18.17.0
nvm use 18.17.0

# „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂàùÊúüÂåñ
mkdir starflect-zodiac-automation
cd starflect-zodiac-automation
npm init -y

# ‰æùÂ≠òÈñ¢‰øÇ„Ç§„É≥„Çπ„Éà„Éº„É´
npm install express mongoose redis node-cron openai
npm install instagram-private-api twitter-api-v2 @tiktok-sdk/api
npm install dotenv cors helmet winston
npm install -D nodemon jest supertest
```

#### „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†
```
starflect-zodiac-automation/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ instagram.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ twitter.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tiktok.js
‚îÇ   ‚îú‚îÄ‚îÄ ai/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contentGenerator.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ promptTemplates.js
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Account.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Post.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Analytics.js
‚îÇ   ‚îú‚îÄ‚îÄ scheduler/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ postScheduler.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cronJobs.js
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helpers.js
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ database.js
‚îÇ   ‚îú‚îÄ‚îÄ redis.js
‚îÇ   ‚îî‚îÄ‚îÄ env.js
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ docs/
‚îî‚îÄ‚îÄ package.json
```

### 1.2 „Éá„Éº„Çø„Éô„Éº„ÇπË®≠Ë®à

#### MongoDB „Çπ„Ç≠„Éº„ÉûË®≠Ë®à
```javascript
// models/Account.js
const mongoose = require('mongoose');

const AccountSchema = new mongoose.Schema({
  zodiacSign: {
    type: String,
    required: true,
    enum: ['Áâ°ÁæäÂ∫ß', 'Áâ°ÁâõÂ∫ß', 'ÂèåÂ≠êÂ∫ß', 'ËüπÂ∫ß', 'ÁçÖÂ≠êÂ∫ß', '‰πôÂ•≥Â∫ß', 
           'Â§©Áß§Â∫ß', 'Ë†çÂ∫ß', 'Â∞ÑÊâãÂ∫ß', 'Â±±ÁæäÂ∫ß', 'Ê∞¥Áì∂Â∫ß', 'È≠öÂ∫ß']
  },
  platform: {
    type: String,
    required: true,
    enum: ['instagram', 'twitter', 'tiktok']
  },
  username: String,
  credentials: {
    accessToken: String,
    refreshToken: String,
    expiresAt: Date
  },
  status: {
    type: String,
    enum: ['active', 'suspended', 'error'],
    default: 'active'
  },
  analytics: {
    followers: Number,
    following: Number,
    posts: Number,
    engagementRate: Number,
    lastUpdate: Date
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// models/Post.js
const PostSchema = new mongoose.Schema({
  accountId: { type: mongoose.Schema.Types.ObjectId, ref: 'Account' },
  content: {
    text: String,
    images: [String],
    hashtags: [String]
  },
  status: {
    type: String,
    enum: ['scheduled', 'published', 'failed'],
    default: 'scheduled'
  },
  scheduledTime: Date,
  publishedTime: Date,
  analytics: {
    likes: Number,
    comments: Number,
    shares: Number,
    saves: Number,
    reach: Number,
    impressions: Number
  },
  createdAt: { type: Date, default: Date.now }
});

module.exports = { Account: mongoose.model('Account', AccountSchema), 
                   Post: mongoose.model('Post', PostSchema) };
```

### 1.3 AI „Ç≥„É≥„ÉÜ„É≥„ÉÑÁîüÊàêÂô®

#### OpenAI API„Çí‰ΩøÁî®„Åó„Åü„Ç≥„É≥„ÉÜ„É≥„ÉÑÁîüÊàê
```javascript
// ai/contentGenerator.js
const OpenAI = require('openai');
const { zodiacPrompts } = require('./promptTemplates');

class ContentGenerator {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async generateDailyFortune(zodiacSign, platform) {
    const prompt = zodiacPrompts[zodiacSign].daily;
    const platformSpecific = this.getPlatformSpecificPrompt(platform);
    
    try {
      const response = await this.openai.chat.completions.create({
        model: "gpt-4-turbo-preview",
        messages: [
          {
            role: "system",
            content: `„ÅÇ„Å™„Åü„ÅØ${zodiacSign}Â∞ÇÈñÄ„ÅÆÂç†„ÅÑÂ∏´„Åß„Åô„ÄÇ${platformSpecific}`
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 500,
        temperature: 0.7
      });
      
      return this.formatContent(response.choices[0].message.content, zodiacSign, platform);
    } catch (error) {
      console.error('AIÁîüÊàê„Ç®„É©„Éº:', error);
      return this.getFallbackContent(zodiacSign, platform);
    }
  }

  getPlatformSpecificPrompt(platform) {
    const platforms = {
      instagram: "InstagramÊäïÁ®øÁî®„ÅÆÈ≠ÖÂäõÁöÑ„Å™ÊñáÁ´†„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁµµÊñáÂ≠ó„ÇíÈÅ©Âàá„Å´‰ΩøÁî®„Åó„ÄÅ„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      twitter: "TwitterÊäïÁ®øÁî®„ÅÆÁ∞°ÊΩî„ÅßÂç∞Ë±°ÁöÑ„Å™ÊñáÁ´†„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ280ÊñáÂ≠ó‰ª•ÂÜÖ„Åß„ÄÅÈñ¢ÈÄ£„Åô„Çã„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      tiktok: "TikTokÊäïÁ®øÁî®„ÅÆËã•„ÅÑ‰∏ñ‰ª£„Å´Èüø„Åè„ÄÅ„Ç®„Éç„É´„ÇÆ„ÉÉ„Ç∑„É•„Å™ÊñáÁ´†„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éà„É¨„É≥„Éâ„ÅÆ„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    };
    return platforms[platform] || platforms.instagram;
  }

  formatContent(content, zodiacSign, platform) {
    const hashtags = this.generateHashtags(zodiacSign, platform);
    return {
      text: content,
      hashtags: hashtags,
      zodiacSign: zodiacSign,
      platform: platform,
      createdAt: new Date()
    };
  }

  generateHashtags(zodiacSign, platform) {
    const commonTags = ['#Âç†„ÅÑ', '#ÈÅãÂã¢', '#‰ªäÊó•„ÅÆÈÅãÂã¢', '#„Çπ„Éî„É™„ÉÅ„É•„Ç¢„É´', '#ÊòüÂ∫ßÂç†„ÅÑ'];
    const zodiacTags = [`#${zodiacSign}`, `#${zodiacSign}„ÅÆÈÅãÂã¢`];
    
    const platformTags = {
      instagram: ['#„Ç§„É≥„Çπ„ÇøÂç†„ÅÑ', '#‰ªäÊó•„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏', '#ÊòüÂ∫ß'],
      twitter: ['#Âç†„ÅÑ„ÉÑ„Ç§„Éº„Éà', '#ÈÅãÂã¢„ÉÅ„Çß„ÉÉ„ÇØ'],
      tiktok: ['#Âç†„ÅÑTikTok', '#ÈÅãÂã¢ÂãïÁîª', '#fyp']
    };
    
    return [...commonTags, ...zodiacTags, ...platformTags[platform]];
  }
}

module.exports = ContentGenerator;
```

### 1.4 SNS API ÈÄ£Êê∫

#### Instagram API ÂÆüË£Ö
```javascript
// api/instagram.js
const { IgApiClient } = require('instagram-private-api');
const fs = require('fs');

class InstagramAPI {
  constructor() {
    this.ig = new IgApiClient();
  }

  async login(username, password) {
    try {
      this.ig.state.generateDevice(username);
      await this.ig.account.login(username, password);
      return true;
    } catch (error) {
      console.error('Instagram „É≠„Ç∞„Ç§„É≥„Ç®„É©„Éº:', error);
      return false;
    }
  }

  async publishPost(content, imagePath = null) {
    try {
      if (imagePath) {
        const imageBuffer = fs.readFileSync(imagePath);
        const publishResult = await this.ig.publish.photo({
          file: imageBuffer,
          caption: `${content.text}\n\n${content.hashtags.join(' ')}`
        });
        return publishResult;
      } else {
        // „ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Åø„ÅÆÊäïÁ®øÔºà„Çπ„Éà„Éº„É™„Éº„Å®„Åó„Å¶ÊäïÁ®øÔºâ
        const publishResult = await this.ig.publish.story({
          text: content.text
        });
        return publishResult;
      }
    } catch (error) {
      console.error('Instagram ÊäïÁ®ø„Ç®„É©„Éº:', error);
      throw error;
    }
  }

  async getAccountInfo() {
    try {
      const userInfo = await this.ig.user.info(this.ig.state.cookieUserId);
      return {
        followers: userInfo.follower_count,
        following: userInfo.following_count,
        posts: userInfo.media_count
      };
    } catch (error) {
      console.error('Instagram ÊÉÖÂ†±ÂèñÂæó„Ç®„É©„Éº:', error);
      return null;
    }
  }
}

module.exports = InstagramAPI;
```

#### Twitter API ÂÆüË£Ö
```javascript
// api/twitter.js
const { TwitterApi } = require('twitter-api-v2');

class TwitterAPI {
  constructor() {
    this.client = new TwitterApi({
      appKey: process.env.TWITTER_API_KEY,
      appSecret: process.env.TWITTER_API_SECRET,
      accessToken: process.env.TWITTER_ACCESS_TOKEN,
      accessSecret: process.env.TWITTER_ACCESS_SECRET,
    });
  }

  async publishTweet(content) {
    try {
      const tweetText = `${content.text}\n\n${content.hashtags.join(' ')}`;
      
      if (tweetText.length > 280) {
        // Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØÁü≠Á∏Æ
        const shortText = content.text.substring(0, 200) + '...';
        const tweet = `${shortText}\n\n${content.hashtags.slice(0, 5).join(' ')}`;
        return await this.client.v2.tweet(tweet);
      }
      
      return await this.client.v2.tweet(tweetText);
    } catch (error) {
      console.error('Twitter ÊäïÁ®ø„Ç®„É©„Éº:', error);
      throw error;
    }
  }

  async getAccountInfo() {
    try {
      const user = await this.client.v2.me({
        'user.fields': ['public_metrics']
      });
      return {
        followers: user.data.public_metrics.followers_count,
        following: user.data.public_metrics.following_count,
        posts: user.data.public_metrics.tweet_count
      };
    } catch (error) {
      console.error('Twitter ÊÉÖÂ†±ÂèñÂæó„Ç®„É©„Éº:', error);
      return null;
    }
  }
}

module.exports = TwitterAPI;
```

### 1.5 ÊäïÁ®ø„Çπ„Ç±„Ç∏„É•„Éº„É©„Éº

#### cron „Ç∏„Éß„ÉñË®≠ÂÆö
```javascript
// scheduler/postScheduler.js
const cron = require('node-cron');
const ContentGenerator = require('../ai/contentGenerator');
const InstagramAPI = require('../api/instagram');
const TwitterAPI = require('../api/twitter');
const { Account, Post } = require('../models');

class PostScheduler {
  constructor() {
    this.contentGenerator = new ContentGenerator();
    this.instagramAPI = new InstagramAPI();
    this.twitterAPI = new TwitterAPI();
  }

  startScheduler() {
    // ÊØéÊó•ÂçàÂâç8ÊôÇ„Å´ÊäïÁ®ø
    cron.schedule('0 8 * * *', async () => {
      console.log('ÂÆöÊúüÊäïÁ®øÈñãÂßã');
      await this.publishDailyPosts();
    });

    // ÊØéÊó•ÂçàÂæå8ÊôÇ„Å´ÊäïÁ®ø
    cron.schedule('0 20 * * *', async () => {
      console.log('Â§ú„ÅÆÊäïÁ®øÈñãÂßã');
      await this.publishEveningPosts();
    });

    // ÊØéÊôÇÈñì„Ç¢„Ç´„Ç¶„É≥„ÉàÊÉÖÂ†±Êõ¥Êñ∞
    cron.schedule('0 * * * *', async () => {
      console.log('„Ç¢„Ç´„Ç¶„É≥„ÉàÊÉÖÂ†±Êõ¥Êñ∞');
      await this.updateAccountAnalytics();
    });
  }

  async publishDailyPosts() {
    try {
      const accounts = await Account.find({ status: 'active' });
      
      for (const account of accounts) {
        const content = await this.contentGenerator.generateDailyFortune(
          account.zodiacSign, 
          account.platform
        );
        
        const post = new Post({
          accountId: account._id,
          content: content,
          scheduledTime: new Date(),
          status: 'scheduled'
        });
        
        await post.save();
        await this.publishPost(account, post);
      }
    } catch (error) {
      console.error('ÊäïÁ®ø„Ç®„É©„Éº:', error);
    }
  }

  async publishPost(account, post) {
    try {
      let result;
      
      switch (account.platform) {
        case 'instagram':
          await this.instagramAPI.login(account.username, account.password);
          result = await this.instagramAPI.publishPost(post.content);
          break;
        case 'twitter':
          result = await this.twitterAPI.publishTweet(post.content);
          break;
        case 'tiktok':
          // TikTok APIÂÆüË£Ö
          break;
      }
      
      post.status = 'published';
      post.publishedTime = new Date();
      await post.save();
      
      console.log(`ÊäïÁ®øÊàêÂäü: ${account.zodiacSign} - ${account.platform}`);
    } catch (error) {
      post.status = 'failed';
      await post.save();
      console.error(`ÊäïÁ®øÂ§±Êïó: ${account.zodiacSign} - ${account.platform}`, error);
    }
  }

  async updateAccountAnalytics() {
    try {
      const accounts = await Account.find({ status: 'active' });
      
      for (const account of accounts) {
        let analytics;
        
        switch (account.platform) {
          case 'instagram':
            analytics = await this.instagramAPI.getAccountInfo();
            break;
          case 'twitter':
            analytics = await this.twitterAPI.getAccountInfo();
            break;
        }
        
        if (analytics) {
          account.analytics = {
            ...analytics,
            lastUpdate: new Date()
          };
          await account.save();
        }
      }
    } catch (error) {
      console.error('„Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„ÇπÊõ¥Êñ∞„Ç®„É©„Éº:', error);
    }
  }
}

module.exports = PostScheduler;
```

### 1.6 ÁÆ°ÁêÜ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ

#### Express.js „Çµ„Éº„Éê„Éº„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
```javascript
// src/app.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const PostScheduler = require('./scheduler/postScheduler');
const { Account, Post } = require('./models');

const app = express();

// „Éü„Éâ„É´„Ç¶„Çß„Ç¢
app.use(helmet());
app.use(cors());
app.use(express.json());

// „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂ö
mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
});

// „Çπ„Ç±„Ç∏„É•„Éº„É©„ÉºÈñãÂßã
const scheduler = new PostScheduler();
scheduler.startScheduler();

// API „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
app.get('/api/accounts', async (req, res) => {
  try {
    const accounts = await Account.find();
    res.json(accounts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/posts', async (req, res) => {
  try {
    const posts = await Post.find().populate('accountId').sort({ createdAt: -1 });
    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/analytics', async (req, res) => {
  try {
    const accounts = await Account.find();
    const analytics = accounts.map(account => ({
      zodiacSign: account.zodiacSign,
      platform: account.platform,
      ...account.analytics
    }));
    res.json(analytics);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÊâãÂãïÊäïÁ®ø„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
app.post('/api/publish', async (req, res) => {
  try {
    const { accountId, content } = req.body;
    const account = await Account.findById(accountId);
    
    if (!account) {
      return res.status(404).json({ error: '„Ç¢„Ç´„Ç¶„É≥„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì' });
    }
    
    const post = new Post({
      accountId: account._id,
      content: content,
      scheduledTime: new Date(),
      status: 'scheduled'
    });
    
    await post.save();
    await scheduler.publishPost(account, post);
    
    res.json({ message: 'ÊäïÁ®ø„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü', post });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`„Çµ„Éº„Éê„Éº„ÅåËµ∑Âãï„Åó„Åæ„Åó„Åü: http://localhost:${PORT}`);
});

module.exports = app;
```

## üîß Phase 2: Êã°ÂºµÂ±ïÈñãÔºà3-5„É∂ÊúàÔºâ

### 2.1 „Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£ÊîπÂñÑ

#### Redis „Ç≠„É£„ÉÉ„Ç∑„É•ÂÆüË£Ö
```javascript
// config/redis.js
const redis = require('redis');

class RedisCache {
  constructor() {
    this.client = redis.createClient({
      host: process.env.REDIS_HOST,
      port: process.env.REDIS_PORT,
      password: process.env.REDIS_PASSWORD
    });
    
    this.client.on('error', (err) => {
      console.error('Redis „Ç®„É©„Éº:', err);
    });
  }

  async get(key) {
    try {
      const data = await this.client.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Redis GET „Ç®„É©„Éº:', error);
      return null;
    }
  }

  async set(key, value, expireInSeconds = 3600) {
    try {
      await this.client.setex(key, expireInSeconds, JSON.stringify(value));
    } catch (error) {
      console.error('Redis SET „Ç®„É©„Éº:', error);
    }
  }

  async del(key) {
    try {
      await this.client.del(key);
    } catch (error) {
      console.error('Redis DEL „Ç®„É©„Éº:', error);
    }
  }
}

module.exports = RedisCache;
```

#### „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÉªÂÜóÈï∑Âåñ
```javascript
// utils/backup.js
const fs = require('fs');
const path = require('path');
const { Account, Post } = require('../models');

class BackupManager {
  constructor() {
    this.backupDir = path.join(__dirname, '../../backups');
    this.ensureBackupDir();
  }

  ensureBackupDir() {
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }

  async createBackup() {
    try {
      const timestamp = new Date().toISOString().replace(/:/g, '-');
      const backupFile = path.join(this.backupDir, `backup-${timestamp}.json`);
      
      const accounts = await Account.find();
      const posts = await Post.find();
      
      const backupData = {
        timestamp: new Date(),
        accounts: accounts,
        posts: posts
      };
      
      fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2));
      console.log(`„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó‰ΩúÊàêÂÆå‰∫Ü: ${backupFile}`);
      
      // 7Êó•‰ª•‰∏äÂè§„ÅÑ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÇíÂâäÈô§
      this.cleanOldBackups();
      
      return backupFile;
    } catch (error) {
      console.error('„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Ç®„É©„Éº:', error);
      throw error;
    }
  }

  cleanOldBackups() {
    const files = fs.readdirSync(this.backupDir);
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    
    files.forEach(file => {
      const filePath = path.join(this.backupDir, file);
      const stats = fs.statSync(filePath);
      
      if (stats.mtime < sevenDaysAgo) {
        fs.unlinkSync(filePath);
        console.log(`Âè§„ÅÑ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÇíÂâäÈô§: ${file}`);
      }
    });
  }
}

module.exports = BackupManager;
```

### 2.2 „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Âº∑Âåñ

#### „Ç®„É©„ÉºÁõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†
```javascript
// utils/errorHandler.js
const winston = require('winston');

class ErrorHandler {
  constructor() {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
        new winston.transports.File({ filename: 'logs/combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });
  }

  logError(error, context = {}) {
    this.logger.error({
      message: error.message,
      stack: error.stack,
      context: context,
      timestamp: new Date().toISOString()
    });
  }

  async handleAPIError(error, accountId, retryCount = 0) {
    const maxRetries = 3;
    const retryDelay = Math.pow(2, retryCount) * 1000; // ÊåáÊï∞„Éê„ÉÉ„ÇØ„Ç™„Éï
    
    this.logError(error, { accountId, retryCount });
    
    if (retryCount < maxRetries) {
      console.log(`${retryDelay}msÂæå„Å´„É™„Éà„É©„Ç§„Åó„Åæ„Åô...`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      return { shouldRetry: true, retryCount: retryCount + 1 };
    }
    
    // ÊúÄÂ§ß„É™„Éà„É©„Ç§ÂõûÊï∞„Å´ÈÅî„Åó„ÅüÂ†¥Âêà„ÄÅ„Ç¢„Ç´„Ç¶„É≥„Éà„Çí‰∏ÄÊôÇÂÅúÊ≠¢
    if (accountId) {
      await Account.findByIdAndUpdate(accountId, { status: 'error' });
    }
    
    return { shouldRetry: false, retryCount: maxRetries };
  }

  async sendAlert(message, severity = 'warning') {
    // Slack„ÄÅEmail„ÄÅSMSÁ≠â„ÅÆ„Ç¢„É©„Éº„ÉàÈÄÅ‰ø°
    console.log(`„Ç¢„É©„Éº„Éà [${severity}]: ${message}`);
    
    // ÂøÖË¶Å„Å´Âøú„Åò„Å¶Â§ñÈÉ®„Çµ„Éº„Éì„Çπ„Å´ÈÄÅ‰ø°
    // await this.sendSlackAlert(message, severity);
    // await this.sendEmailAlert(message, severity);
  }
}

module.exports = ErrorHandler;
```

## üöÄ Phase 3: ÂÆåÂÖ®Â±ïÈñãÔºà6-8„É∂ÊúàÔºâ

### 3.1 Ê©üÊ¢∞Â≠¶Áøí„Å´„Çà„ÇãÊúÄÈÅ©Âåñ

#### „Ç≥„É≥„ÉÜ„É≥„ÉÑÂäπÊûúÂàÜÊûê
```javascript
// ai/contentAnalyzer.js
const tf = require('@tensorflow/tfjs-node');

class ContentAnalyzer {
  constructor() {
    this.model = null;
    this.loadModel();
  }

  async loadModel() {
    try {
      // ‰∫ãÂâçÂ≠¶ÁøíÊ∏à„Åø„É¢„Éá„É´„ÅÆË™≠„ÅøËæº„Åø
      this.model = await tf.loadLayersModel('file://./models/engagement-model.json');
      console.log('Ê©üÊ¢∞Â≠¶Áøí„É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü');
    } catch (error) {
      console.error('„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ
    }
  }

  async predictEngagement(content, accountData) {
    if (!this.model) {
      return this.getBaselineEngagement(accountData);
    }

    try {
      const features = this.extractFeatures(content, accountData);
      const prediction = this.model.predict(features);
      return await prediction.data();
    } catch (error) {
      console.error('‰∫àÊ∏¨„Ç®„É©„Éº:', error);
      return this.getBaselineEngagement(accountData);
    }
  }

  extractFeatures(content, accountData) {
    const features = [
      content.text.length,
      content.hashtags.length,
      accountData.followers,
      accountData.engagementRate,
      this.getTimeScore(new Date()),
      this.getEmotionScore(content.text),
      this.getKeywordScore(content.text, accountData.zodiacSign)
    ];

    return tf.tensor2d([features]);
  }

  getTimeScore(date) {
    const hour = date.getHours();
    // Êúù8ÊôÇ„Å®Â§ú8ÊôÇ„Å´È´ò„Çπ„Ç≥„Ç¢
    if (hour >= 7 && hour <= 9) return 1.0;
    if (hour >= 19 && hour <= 21) return 1.0;
    return 0.5;
  }

  getEmotionScore(text) {
    const positiveWords = ['Âπ∏ÈÅã', 'ÊàêÂäü', 'ÊÑõ', 'Âñú„Å≥', 'Â∏åÊúõ'];
    const negativeWords = ['Ê≥®ÊÑè', 'Âõ∞Èõ£', 'ÂïèÈ°å', 'ÂøÉÈÖç'];
    
    let score = 0;
    positiveWords.forEach(word => {
      if (text.includes(word)) score += 0.2;
    });
    negativeWords.forEach(word => {
      if (text.includes(word)) score -= 0.1;
    });
    
    return Math.max(0, Math.min(1, score + 0.5));
  }

  getKeywordScore(text, zodiacSign) {
    const keywords = this.getZodiacKeywords(zodiacSign);
    let score = 0;
    
    keywords.forEach(keyword => {
      if (text.includes(keyword)) score += 0.1;
    });
    
    return Math.min(1, score);
  }

  getZodiacKeywords(zodiacSign) {
    const keywords = {
      'Áâ°ÁæäÂ∫ß': ['„É™„Éº„ÉÄ„Éº„Ç∑„ÉÉ„Éó', 'ÊåëÊà¶', 'Ë°åÂãïÂäõ', 'ÂãáÊ∞ó'],
      'Áâ°ÁâõÂ∫ß': ['ÂÆâÂÆö', 'Áæé', 'Á∂ôÁ∂ö', 'ÂÆüÁî®ÊÄß'],
      'ÂèåÂ≠êÂ∫ß': ['„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥', 'Â•ΩÂ•áÂøÉ', 'Â§âÂåñ', 'Â≠¶Áøí'],
      // ... ‰ªñ„ÅÆÊòüÂ∫ß„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ
    };
    
    return keywords[zodiacSign] || [];
  }

  getBaselineEngagement(accountData) {
    return [accountData.engagementRate || 0.05];
  }
}

module.exports = ContentAnalyzer;
```

### 3.2 A/B„ÉÜ„Çπ„ÉàÊ©üËÉΩ

#### „Ç≥„É≥„ÉÜ„É≥„ÉÑÊØîËºÉ„ÉÜ„Çπ„Éà
```javascript
// utils/abTesting.js
class ABTesting {
  constructor() {
    this.experiments = new Map();
  }

  createExperiment(name, variants) {
    const experiment = {
      name,
      variants,
      results: variants.map(v => ({
        variant: v,
        impressions: 0,
        engagements: 0,
        conversions: 0
      })),
      isActive: true,
      createdAt: new Date()
    };
    
    this.experiments.set(name, experiment);
    return experiment;
  }

  assignVariant(experimentName, userId) {
    const experiment = this.experiments.get(experimentName);
    if (!experiment || !experiment.isActive) {
      return null;
    }
    
    // „É¶„Éº„Ç∂„ÉºID„Å´Âü∫„Å•„ÅÑ„Å¶‰∏ÄË≤´„Åó„ÅüÂâ≤„ÇäÂΩì„Å¶
    const hash = this.hashUserId(userId);
    const variantIndex = hash % experiment.variants.length;
    
    return experiment.variants[variantIndex];
  }

  recordImpression(experimentName, variant) {
    const experiment = this.experiments.get(experimentName);
    if (experiment) {
      const result = experiment.results.find(r => r.variant === variant);
      if (result) {
        result.impressions++;
      }
    }
  }

  recordEngagement(experimentName, variant) {
    const experiment = this.experiments.get(experimentName);
    if (experiment) {
      const result = experiment.results.find(r => r.variant === variant);
      if (result) {
        result.engagements++;
      }
    }
  }

  recordConversion(experimentName, variant) {
    const experiment = this.experiments.get(experimentName);
    if (experiment) {
      const result = experiment.results.find(r => r.variant === variant);
      if (result) {
        result.conversions++;
      }
    }
  }

  getResults(experimentName) {
    const experiment = this.experiments.get(experimentName);
    if (!experiment) {
      return null;
    }
    
    return experiment.results.map(result => ({
      variant: result.variant,
      impressions: result.impressions,
      engagements: result.engagements,
      conversions: result.conversions,
      engagementRate: result.impressions > 0 ? result.engagements / result.impressions : 0,
      conversionRate: result.impressions > 0 ? result.conversions / result.impressions : 0
    }));
  }

  hashUserId(userId) {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      const char = userId.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32bitÊï¥Êï∞„Å´Â§âÊèõ
    }
    return Math.abs(hash);
  }
}

module.exports = ABTesting;
```

## üìä Phase 4: ÊúÄÈÅ©ÂåñÔºà9-12„É∂ÊúàÔºâ

### 4.1 È´òÂ∫¶„Å™ÂàÜÊûêÊ©üËÉΩ

#### Á∑èÂêà„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ
```javascript
// analytics/dashboard.js
class AnalyticsDashboard {
  constructor() {
    this.metrics = {
      engagement: [],
      growth: [],
      revenue: [],
      conversion: []
    };
  }

  async generateReport(dateRange) {
    const report = {
      summary: await this.getSummary(dateRange),
      engagement: await this.getEngagementMetrics(dateRange),
      growth: await this.getGrowthMetrics(dateRange),
      revenue: await this.getRevenueMetrics(dateRange),
      topContent: await this.getTopContent(dateRange),
      recommendations: await this.getRecommendations(dateRange)
    };
    
    return report;
  }

  async getSummary(dateRange) {
    const accounts = await Account.find();
    const posts = await Post.find({
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    });
    
    const totalFollowers = accounts.reduce((sum, acc) => sum + (acc.analytics.followers || 0), 0);
    const totalPosts = posts.length;
    const avgEngagement = this.calculateAverageEngagement(posts);
    
    return {
      totalAccounts: accounts.length,
      totalFollowers,
      totalPosts,
      avgEngagement,
      period: dateRange
    };
  }

  async getEngagementMetrics(dateRange) {
    const posts = await Post.find({
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    }).populate('accountId');
    
    const metrics = {};
    
    posts.forEach(post => {
      const zodiac = post.accountId.zodiacSign;
      const platform = post.accountId.platform;
      
      if (!metrics[zodiac]) {
        metrics[zodiac] = {};
      }
      
      if (!metrics[zodiac][platform]) {
        metrics[zodiac][platform] = {
          likes: 0,
          comments: 0,
          shares: 0,
          posts: 0
        };
      }
      
      metrics[zodiac][platform].likes += post.analytics.likes || 0;
      metrics[zodiac][platform].comments += post.analytics.comments || 0;
      metrics[zodiac][platform].shares += post.analytics.shares || 0;
      metrics[zodiac][platform].posts += 1;
    });
    
    return metrics;
  }

  async getGrowthMetrics(dateRange) {
    const accounts = await Account.find();
    const growth = {};
    
    for (const account of accounts) {
      const historicalData = await this.getHistoricalData(account._id, dateRange);
      
      if (!growth[account.zodiacSign]) {
        growth[account.zodiacSign] = {};
      }
      
      growth[account.zodiacSign][account.platform] = {
        followerGrowth: this.calculateGrowthRate(historicalData.followers),
        engagementGrowth: this.calculateGrowthRate(historicalData.engagement),
        postGrowth: this.calculateGrowthRate(historicalData.posts)
      };
    }
    
    return growth;
  }

  async getRevenueMetrics(dateRange) {
    // Starflect„Ç¢„Éó„É™„ÅÆAPIÈÄ£Êê∫„ÅßÂèéÁõä„Éá„Éº„Çø„ÇíÂèñÂæó
    const revenueData = await this.fetchRevenueData(dateRange);
    
    return {
      totalRevenue: revenueData.total,
      revenueBySource: revenueData.bySource,
      conversionRate: revenueData.conversions / revenueData.visitors,
      averageRevenue: revenueData.total / revenueData.conversions
    };
  }

  async getTopContent(dateRange) {
    const posts = await Post.find({
      createdAt: { $gte: dateRange.start, $lte: dateRange.end }
    }).populate('accountId');
    
    return posts
      .sort((a, b) => (b.analytics.likes + b.analytics.comments + b.analytics.shares) - 
                      (a.analytics.likes + a.analytics.comments + a.analytics.shares))
      .slice(0, 10)
      .map(post => ({
        zodiacSign: post.accountId.zodiacSign,
        platform: post.accountId.platform,
        content: post.content.text.substring(0, 100),
        totalEngagement: post.analytics.likes + post.analytics.comments + post.analytics.shares,
        publishedTime: post.publishedTime
      }));
  }

  async getRecommendations(dateRange) {
    const metrics = await this.getEngagementMetrics(dateRange);
    const recommendations = [];
    
    // ‰Ωé„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÅÆ„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÁâπÂÆö
    for (const [zodiac, platforms] of Object.entries(metrics)) {
      for (const [platform, data] of Object.entries(platforms)) {
        const avgEngagement = (data.likes + data.comments + data.shares) / data.posts;
        
        if (avgEngagement < 50) {
          recommendations.push({
            type: 'improvement',
            zodiac,
            platform,
            message: `${zodiac}„ÅÆ${platform}„Ç¢„Ç´„Ç¶„É≥„Éà„ÅÆ„Ç®„É≥„Ç≤„Éº„Ç∏„É°„É≥„Éà„Åå‰Ωé‰∏ã„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆË¶ãÁõ¥„Åó„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ`,
            priority: 'high'
          });
        }
      }
    }
    
    return recommendations;
  }

  calculateAverageEngagement(posts) {
    if (posts.length === 0) return 0;
    
    const totalEngagement = posts.reduce((sum, post) => 
      sum + (post.analytics.likes || 0) + (post.analytics.comments || 0) + (post.analytics.shares || 0), 0);
    
    return totalEngagement / posts.length;
  }

  calculateGrowthRate(data) {
    if (data.length < 2) return 0;
    
    const start = data[0];
    const end = data[data.length - 1];
    
    return ((end - start) / start) * 100;
  }
}

module.exports = AnalyticsDashboard;
```

## üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉªÈÅãÁî®ÁÆ°ÁêÜ

### „Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂØæÁ≠ñ
```javascript
// security/security.js
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');

class SecurityManager {
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET;
    this.setupRateLimit();
  }

  setupRateLimit() {
    this.limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15ÂàÜ
      max: 100, // ÊúÄÂ§ß100„É™„ÇØ„Ç®„Çπ„Éà
      message: '„É™„ÇØ„Ç®„Çπ„Éà„ÅåÂ§ö„Åô„Åé„Åæ„Åô„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
    });
  }

  async hashPassword(password) {
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }

  async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }

  generateToken(payload) {
    return jwt.sign(payload, this.jwtSecret, { expiresIn: '24h' });
  }

  verifyToken(token) {
    try {
      return jwt.verify(token, this.jwtSecret);
    } catch (error) {
      return null;
    }
  }

  encryptSensitiveData(data) {
    const crypto = require('crypto');
    const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  decryptSensitiveData(encryptedData) {
    const crypto = require('crypto');
    const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }
}

module.exports = SecurityManager;
```

## üìù „Éá„Éó„É≠„Ç§„É°„É≥„ÉàÊâãÈ†Ü

### DockerË®≠ÂÆö
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

CMD ["node", "src/app.js"]
```

### Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongo:27017/starflect
      - REDIS_HOST=redis
    depends_on:
      - mongo
      - redis
    restart: unless-stopped

  mongo:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  mongo-data:
  redis-data:
```

## üéØ ÈÅãÁî®„ÉªÁõ£Ë¶ñ

### Áõ£Ë¶ñË®≠ÂÆö
```javascript
// monitoring/monitor.js
const prometheus = require('prom-client');

class MonitoringSystem {
  constructor() {
    this.register = new prometheus.Registry();
    this.setupMetrics();
  }

  setupMetrics() {
    this.postsTotal = new prometheus.Counter({
      name: 'posts_total',
      help: 'ÊäïÁ®øÁ∑èÊï∞',
      labelNames: ['zodiac', 'platform', 'status']
    });

    this.engagementRate = new prometheus.Gauge({
      name: 'engagement_rate',
      help: '„Ç®„É≥„Ç≤„Éº„Ç∏„É°„É≥„ÉàÁéá',
      labelNames: ['zodiac', 'platform']
    });

    this.apiResponseTime = new prometheus.Histogram({
      name: 'api_response_time',
      help: 'APIÂøúÁ≠îÊôÇÈñì',
      labelNames: ['method', 'route', 'status']
    });

    this.register.registerMetric(this.postsTotal);
    this.register.registerMetric(this.engagementRate);
    this.register.registerMetric(this.apiResponseTime);
  }

  recordPost(zodiac, platform, status) {
    this.postsTotal.labels(zodiac, platform, status).inc();
  }

  updateEngagementRate(zodiac, platform, rate) {
    this.engagementRate.labels(zodiac, platform).set(rate);
  }

  recordAPIResponse(method, route, status, duration) {
    this.apiResponseTime.labels(method, route, status).observe(duration);
  }

  getMetrics() {
    return this.register.metrics();
  }
}

module.exports = MonitoringSystem;
```

---

## üìö „Åæ„Å®„ÇÅ

„Åì„ÅÆÂÆüË£ÖÊâãÈ†ÜÊõ∏„Åß„ÅØ„ÄÅ12ÊòüÂ∫ßÂà•„Ç¢„Ç´„Ç¶„É≥„ÉàÊà¶Áï•„ÅÆÊäÄË°ìÁöÑÂÆüË£Ö„Å´„Å§„ÅÑ„Å¶Ë©≥Á¥∞„Å´Ë™¨Êòé„Åó„Åæ„Åó„Åü„ÄÇ

### ‰∏ªË¶Å„Å™ÂÆüË£Ö„Éù„Ç§„É≥„Éà
1. **ÊÆµÈöéÁöÑÂÆüË£Ö**: „É™„Çπ„ÇØ„ÇíÊúÄÂ∞èÈôê„Å´Êäë„Åà„ÅüÊÆµÈöéÁöÑ„Å™Â±ïÈñã
2. **Ëá™ÂãïÂåñ**: AIÁîüÊàê„Åã„ÇâSNSÊäïÁ®ø„Åæ„ÅßÂÆåÂÖ®Ëá™ÂãïÂåñ
3. **Áõ£Ë¶ñ**: ÂåÖÊã¨ÁöÑ„Å™Áõ£Ë¶ñ„ÉªÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†
4. **„Çª„Ç≠„É•„É™„ÉÜ„Ç£**: ‰ºÅÊ•≠„É¨„Éô„É´„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂØæÁ≠ñ
5. **„Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£**: Â∞ÜÊù•„ÅÆÊã°Âºµ„Å´ÂØæÂøú„Åó„ÅüË®≠Ë®à

### ÊàêÂäü„ÅÆ„Åü„ÇÅ„ÅÆÈáçË¶ÅË¶ÅÁ¥†
- **Á∂ôÁ∂öÁöÑ„Å™ÊîπÂñÑ**: „Éá„Éº„Çø„Å´Âü∫„Å•„ÅèÁ∂ôÁ∂öÁöÑ„Å™ÊúÄÈÅ©Âåñ
- **ÂìÅË≥™ÁÆ°ÁêÜ**: AIÁîüÊàê„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆÂìÅË≥™Á∂≠ÊåÅ
- **„É™„Çπ„ÇØÁÆ°ÁêÜ**: „Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†Ë¶èÁ¥Ñ„ÅÆÈÅµÂÆà
- **Áõ£Ë¶ñ‰ΩìÂà∂**: 24/7„ÅÆÁõ£Ë¶ñ„ÉªÂØæÂøú‰ΩìÂà∂

„Åì„ÅÆÊâãÈ†ÜÊõ∏„Å´Âæì„Å£„Å¶ÂÆüË£Ö„Åô„Çã„Åì„Å®„Åß„ÄÅÂèéÁõäÊÄß„ÅÆÈ´ò„ÅÑ12ÊòüÂ∫ßÂà•„Ç¢„Ç´„Ç¶„É≥„ÉàÊà¶Áï•„ÇíÂÆüÁèæ„Åß„Åç„Åæ„Åô„ÄÇ

---

**ÊúÄÁµÇÊõ¥Êñ∞**: 2025Âπ¥1Êúà9Êó•
**„Éê„Éº„Ç∏„Éß„É≥**: 1.0 